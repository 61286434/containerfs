// Code generated by protoc-gen-go.
// source: datanode.proto
// DO NOT EDIT!

/*
Package dp is a generated protocol buffer package.

It is generated from these files:
	datanode.proto

It has these top-level messages:
	WriteChunkReq
	WriteChunkAck
	Block
	CreateBlockGroupStreamReq
	CreateBlockGroupStreamAck
	StreamWriteReq
	StreamWriteAck
	StreamReadChunkReq
	StreamReadChunkAck
	DeleteChunkReq
	DeleteChunkAck
	DataNodeHealthCheckReq
	DataNodeHealthCheckAck
	RecvMigrateReq
	RecvMigrateAck
	FInfo
	SendAck
	NodeMonitorReq
	NodeMonitorAck
	NodeInfo
	DiskIO
	NetIO
*/
package dp

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WriteChunkReq struct {
	ChunkID  uint64 `protobuf:"varint,1,opt,name=ChunkID" json:"ChunkID,omitempty"`
	BlockID  uint64 `protobuf:"varint,2,opt,name=BlockID" json:"BlockID,omitempty"`
	Databuf  []byte `protobuf:"bytes,3,opt,name=Databuf,proto3" json:"Databuf,omitempty"`
	CommitID uint64 `protobuf:"varint,4,opt,name=CommitID" json:"CommitID,omitempty"`
}

func (m *WriteChunkReq) Reset()                    { *m = WriteChunkReq{} }
func (m *WriteChunkReq) String() string            { return proto.CompactTextString(m) }
func (*WriteChunkReq) ProtoMessage()               {}
func (*WriteChunkReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *WriteChunkReq) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *WriteChunkReq) GetBlockID() uint64 {
	if m != nil {
		return m.BlockID
	}
	return 0
}

func (m *WriteChunkReq) GetDatabuf() []byte {
	if m != nil {
		return m.Databuf
	}
	return nil
}

func (m *WriteChunkReq) GetCommitID() uint64 {
	if m != nil {
		return m.CommitID
	}
	return 0
}

type WriteChunkAck struct {
	Ret      int32  `protobuf:"varint,1,opt,name=Ret" json:"Ret,omitempty"`
	CommitID uint64 `protobuf:"varint,2,opt,name=CommitID" json:"CommitID,omitempty"`
}

func (m *WriteChunkAck) Reset()                    { *m = WriteChunkAck{} }
func (m *WriteChunkAck) String() string            { return proto.CompactTextString(m) }
func (*WriteChunkAck) ProtoMessage()               {}
func (*WriteChunkAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *WriteChunkAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

func (m *WriteChunkAck) GetCommitID() uint64 {
	if m != nil {
		return m.CommitID
	}
	return 0
}

type Block struct {
	Host    string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	BlockID uint64 `protobuf:"varint,2,opt,name=BlockID" json:"BlockID,omitempty"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Block) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Block) GetBlockID() uint64 {
	if m != nil {
		return m.BlockID
	}
	return 0
}

type CreateBlockGroupStreamReq struct {
	SlaveHost    string `protobuf:"bytes,1,opt,name=SlaveHost" json:"SlaveHost,omitempty"`
	BlockGroupID uint64 `protobuf:"varint,2,opt,name=BlockGroupID" json:"BlockGroupID,omitempty"`
}

func (m *CreateBlockGroupStreamReq) Reset()                    { *m = CreateBlockGroupStreamReq{} }
func (m *CreateBlockGroupStreamReq) String() string            { return proto.CompactTextString(m) }
func (*CreateBlockGroupStreamReq) ProtoMessage()               {}
func (*CreateBlockGroupStreamReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateBlockGroupStreamReq) GetSlaveHost() string {
	if m != nil {
		return m.SlaveHost
	}
	return ""
}

func (m *CreateBlockGroupStreamReq) GetBlockGroupID() uint64 {
	if m != nil {
		return m.BlockGroupID
	}
	return 0
}

type CreateBlockGroupStreamAck struct {
	Ret int32 `protobuf:"varint,1,opt,name=ret" json:"ret,omitempty"`
}

func (m *CreateBlockGroupStreamAck) Reset()                    { *m = CreateBlockGroupStreamAck{} }
func (m *CreateBlockGroupStreamAck) String() string            { return proto.CompactTextString(m) }
func (*CreateBlockGroupStreamAck) ProtoMessage()               {}
func (*CreateBlockGroupStreamAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateBlockGroupStreamAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

type StreamWriteReq struct {
	ChunkID      uint64 `protobuf:"varint,1,opt,name=ChunkID" json:"ChunkID,omitempty"`
	Databuf      []byte `protobuf:"bytes,2,opt,name=Databuf,proto3" json:"Databuf,omitempty"`
	DataLen      uint32 `protobuf:"varint,3,opt,name=DataLen" json:"DataLen,omitempty"`
	CommitID     uint64 `protobuf:"varint,4,opt,name=CommitID" json:"CommitID,omitempty"`
	Master       *Block `protobuf:"bytes,5,opt,name=Master" json:"Master,omitempty"`
	Slave        *Block `protobuf:"bytes,6,opt,name=Slave" json:"Slave,omitempty"`
	Backup       *Block `protobuf:"bytes,7,opt,name=Backup" json:"Backup,omitempty"`
	BlockGroupID uint64 `protobuf:"varint,8,opt,name=BlockGroupID" json:"BlockGroupID,omitempty"`
	StreamID     uint64 `protobuf:"varint,9,opt,name=StreamID" json:"StreamID,omitempty"`
}

func (m *StreamWriteReq) Reset()                    { *m = StreamWriteReq{} }
func (m *StreamWriteReq) String() string            { return proto.CompactTextString(m) }
func (*StreamWriteReq) ProtoMessage()               {}
func (*StreamWriteReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *StreamWriteReq) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *StreamWriteReq) GetDatabuf() []byte {
	if m != nil {
		return m.Databuf
	}
	return nil
}

func (m *StreamWriteReq) GetDataLen() uint32 {
	if m != nil {
		return m.DataLen
	}
	return 0
}

func (m *StreamWriteReq) GetCommitID() uint64 {
	if m != nil {
		return m.CommitID
	}
	return 0
}

func (m *StreamWriteReq) GetMaster() *Block {
	if m != nil {
		return m.Master
	}
	return nil
}

func (m *StreamWriteReq) GetSlave() *Block {
	if m != nil {
		return m.Slave
	}
	return nil
}

func (m *StreamWriteReq) GetBackup() *Block {
	if m != nil {
		return m.Backup
	}
	return nil
}

func (m *StreamWriteReq) GetBlockGroupID() uint64 {
	if m != nil {
		return m.BlockGroupID
	}
	return 0
}

func (m *StreamWriteReq) GetStreamID() uint64 {
	if m != nil {
		return m.StreamID
	}
	return 0
}

type StreamWriteAck struct {
	Ret          int32  `protobuf:"varint,1,opt,name=Ret" json:"Ret,omitempty"`
	ChunkID      uint64 `protobuf:"varint,2,opt,name=ChunkID" json:"ChunkID,omitempty"`
	CommitID     uint64 `protobuf:"varint,3,opt,name=CommitID" json:"CommitID,omitempty"`
	DataLen      uint32 `protobuf:"varint,4,opt,name=DataLen" json:"DataLen,omitempty"`
	BlockGroupID uint64 `protobuf:"varint,5,opt,name=BlockGroupID" json:"BlockGroupID,omitempty"`
	StreamID     uint64 `protobuf:"varint,6,opt,name=StreamID" json:"StreamID,omitempty"`
}

func (m *StreamWriteAck) Reset()                    { *m = StreamWriteAck{} }
func (m *StreamWriteAck) String() string            { return proto.CompactTextString(m) }
func (*StreamWriteAck) ProtoMessage()               {}
func (*StreamWriteAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *StreamWriteAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

func (m *StreamWriteAck) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *StreamWriteAck) GetCommitID() uint64 {
	if m != nil {
		return m.CommitID
	}
	return 0
}

func (m *StreamWriteAck) GetDataLen() uint32 {
	if m != nil {
		return m.DataLen
	}
	return 0
}

func (m *StreamWriteAck) GetBlockGroupID() uint64 {
	if m != nil {
		return m.BlockGroupID
	}
	return 0
}

func (m *StreamWriteAck) GetStreamID() uint64 {
	if m != nil {
		return m.StreamID
	}
	return 0
}

type StreamReadChunkReq struct {
	ChunkID  uint64 `protobuf:"varint,1,opt,name=ChunkID" json:"ChunkID,omitempty"`
	BlockID  uint64 `protobuf:"varint,2,opt,name=BlockID" json:"BlockID,omitempty"`
	Offset   int64  `protobuf:"varint,3,opt,name=Offset" json:"Offset,omitempty"`
	Readsize int64  `protobuf:"varint,4,opt,name=Readsize" json:"Readsize,omitempty"`
}

func (m *StreamReadChunkReq) Reset()                    { *m = StreamReadChunkReq{} }
func (m *StreamReadChunkReq) String() string            { return proto.CompactTextString(m) }
func (*StreamReadChunkReq) ProtoMessage()               {}
func (*StreamReadChunkReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *StreamReadChunkReq) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *StreamReadChunkReq) GetBlockID() uint64 {
	if m != nil {
		return m.BlockID
	}
	return 0
}

func (m *StreamReadChunkReq) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *StreamReadChunkReq) GetReadsize() int64 {
	if m != nil {
		return m.Readsize
	}
	return 0
}

type StreamReadChunkAck struct {
	Databuf []byte `protobuf:"bytes,1,opt,name=Databuf,proto3" json:"Databuf,omitempty"`
}

func (m *StreamReadChunkAck) Reset()                    { *m = StreamReadChunkAck{} }
func (m *StreamReadChunkAck) String() string            { return proto.CompactTextString(m) }
func (*StreamReadChunkAck) ProtoMessage()               {}
func (*StreamReadChunkAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *StreamReadChunkAck) GetDatabuf() []byte {
	if m != nil {
		return m.Databuf
	}
	return nil
}

type DeleteChunkReq struct {
	ChunkID uint64 `protobuf:"varint,1,opt,name=ChunkID" json:"ChunkID,omitempty"`
	BlockID uint64 `protobuf:"varint,2,opt,name=BlockID" json:"BlockID,omitempty"`
}

func (m *DeleteChunkReq) Reset()                    { *m = DeleteChunkReq{} }
func (m *DeleteChunkReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteChunkReq) ProtoMessage()               {}
func (*DeleteChunkReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteChunkReq) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *DeleteChunkReq) GetBlockID() uint64 {
	if m != nil {
		return m.BlockID
	}
	return 0
}

type DeleteChunkAck struct {
	Ret int32 `protobuf:"varint,1,opt,name=Ret" json:"Ret,omitempty"`
}

func (m *DeleteChunkAck) Reset()                    { *m = DeleteChunkAck{} }
func (m *DeleteChunkAck) String() string            { return proto.CompactTextString(m) }
func (*DeleteChunkAck) ProtoMessage()               {}
func (*DeleteChunkAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeleteChunkAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

type DataNodeHealthCheckReq struct {
}

func (m *DataNodeHealthCheckReq) Reset()                    { *m = DataNodeHealthCheckReq{} }
func (m *DataNodeHealthCheckReq) String() string            { return proto.CompactTextString(m) }
func (*DataNodeHealthCheckReq) ProtoMessage()               {}
func (*DataNodeHealthCheckReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type DataNodeHealthCheckAck struct {
	Ret    int32 `protobuf:"varint,1,opt,name=Ret" json:"Ret,omitempty"`
	Used   int32 `protobuf:"varint,2,opt,name=Used" json:"Used,omitempty"`
	Status int32 `protobuf:"varint,3,opt,name=Status" json:"Status,omitempty"`
}

func (m *DataNodeHealthCheckAck) Reset()                    { *m = DataNodeHealthCheckAck{} }
func (m *DataNodeHealthCheckAck) String() string            { return proto.CompactTextString(m) }
func (*DataNodeHealthCheckAck) ProtoMessage()               {}
func (*DataNodeHealthCheckAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DataNodeHealthCheckAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

func (m *DataNodeHealthCheckAck) GetUsed() int32 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DataNodeHealthCheckAck) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type RecvMigrateReq struct {
	SrcBlkID uint64 `protobuf:"varint,1,opt,name=SrcBlkID" json:"SrcBlkID,omitempty"`
	SrcMount string `protobuf:"bytes,2,opt,name=SrcMount" json:"SrcMount,omitempty"`
	DstBlkID uint64 `protobuf:"varint,3,opt,name=DstBlkID" json:"DstBlkID,omitempty"`
	DstHost  string `protobuf:"bytes,4,opt,name=DstHost" json:"DstHost,omitempty"`
	DstMount string `protobuf:"bytes,6,opt,name=DstMount" json:"DstMount,omitempty"`
}

func (m *RecvMigrateReq) Reset()                    { *m = RecvMigrateReq{} }
func (m *RecvMigrateReq) String() string            { return proto.CompactTextString(m) }
func (*RecvMigrateReq) ProtoMessage()               {}
func (*RecvMigrateReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RecvMigrateReq) GetSrcBlkID() uint64 {
	if m != nil {
		return m.SrcBlkID
	}
	return 0
}

func (m *RecvMigrateReq) GetSrcMount() string {
	if m != nil {
		return m.SrcMount
	}
	return ""
}

func (m *RecvMigrateReq) GetDstBlkID() uint64 {
	if m != nil {
		return m.DstBlkID
	}
	return 0
}

func (m *RecvMigrateReq) GetDstHost() string {
	if m != nil {
		return m.DstHost
	}
	return ""
}

func (m *RecvMigrateReq) GetDstMount() string {
	if m != nil {
		return m.DstMount
	}
	return ""
}

type RecvMigrateAck struct {
	Ret int32 `protobuf:"varint,1,opt,name=Ret" json:"Ret,omitempty"`
}

func (m *RecvMigrateAck) Reset()                    { *m = RecvMigrateAck{} }
func (m *RecvMigrateAck) String() string            { return proto.CompactTextString(m) }
func (*RecvMigrateAck) ProtoMessage()               {}
func (*RecvMigrateAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RecvMigrateAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

type FInfo struct {
	DstBlkID uint64 `protobuf:"varint,1,opt,name=DstBlkID" json:"DstBlkID,omitempty"`
	DstMount string `protobuf:"bytes,2,opt,name=DstMount" json:"DstMount,omitempty"`
	FName    string `protobuf:"bytes,3,opt,name=FName" json:"FName,omitempty"`
	DataBuf  []byte `protobuf:"bytes,4,opt,name=DataBuf,proto3" json:"DataBuf,omitempty"`
}

func (m *FInfo) Reset()                    { *m = FInfo{} }
func (m *FInfo) String() string            { return proto.CompactTextString(m) }
func (*FInfo) ProtoMessage()               {}
func (*FInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *FInfo) GetDstBlkID() uint64 {
	if m != nil {
		return m.DstBlkID
	}
	return 0
}

func (m *FInfo) GetDstMount() string {
	if m != nil {
		return m.DstMount
	}
	return ""
}

func (m *FInfo) GetFName() string {
	if m != nil {
		return m.FName
	}
	return ""
}

func (m *FInfo) GetDataBuf() []byte {
	if m != nil {
		return m.DataBuf
	}
	return nil
}

type SendAck struct {
	Ret int32 `protobuf:"varint,1,opt,name=Ret" json:"Ret,omitempty"`
}

func (m *SendAck) Reset()                    { *m = SendAck{} }
func (m *SendAck) String() string            { return proto.CompactTextString(m) }
func (*SendAck) ProtoMessage()               {}
func (*SendAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *SendAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

// web -> the datanode
type NodeMonitorReq struct {
}

func (m *NodeMonitorReq) Reset()                    { *m = NodeMonitorReq{} }
func (m *NodeMonitorReq) String() string            { return proto.CompactTextString(m) }
func (*NodeMonitorReq) ProtoMessage()               {}
func (*NodeMonitorReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type NodeMonitorAck struct {
	Ret      int32     `protobuf:"varint,1,opt,name=Ret" json:"Ret,omitempty"`
	NodeInfo *NodeInfo `protobuf:"bytes,2,opt,name=NodeInfo" json:"NodeInfo,omitempty"`
}

func (m *NodeMonitorAck) Reset()                    { *m = NodeMonitorAck{} }
func (m *NodeMonitorAck) String() string            { return proto.CompactTextString(m) }
func (*NodeMonitorAck) ProtoMessage()               {}
func (*NodeMonitorAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *NodeMonitorAck) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

func (m *NodeMonitorAck) GetNodeInfo() *NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

type NodeInfo struct {
	CpuUsage        float64   `protobuf:"fixed64,1,opt,name=CpuUsage" json:"CpuUsage,omitempty"`
	CpuLoad         float64   `protobuf:"fixed64,2,opt,name=CpuLoad" json:"CpuLoad,omitempty"`
	FreeMem         uint64    `protobuf:"varint,3,opt,name=FreeMem" json:"FreeMem,omitempty"`
	TotalMem        uint64    `protobuf:"varint,4,opt,name=TotalMem" json:"TotalMem,omitempty"`
	MemUsedPercent  float64   `protobuf:"fixed64,5,opt,name=MemUsedPercent" json:"MemUsedPercent,omitempty"`
	PathTotal       uint64    `protobuf:"varint,6,opt,name=PathTotal" json:"PathTotal,omitempty"`
	PathFree        uint64    `protobuf:"varint,7,opt,name=PathFree" json:"PathFree,omitempty"`
	PathUsedPercent float64   `protobuf:"fixed64,8,opt,name=PathUsedPercent" json:"PathUsedPercent,omitempty"`
	DiskIOs         []*DiskIO `protobuf:"bytes,9,rep,name=DiskIOs" json:"DiskIOs,omitempty"`
	NetIOs          []*NetIO  `protobuf:"bytes,10,rep,name=NetIOs" json:"NetIOs,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *NodeInfo) GetCpuUsage() float64 {
	if m != nil {
		return m.CpuUsage
	}
	return 0
}

func (m *NodeInfo) GetCpuLoad() float64 {
	if m != nil {
		return m.CpuLoad
	}
	return 0
}

func (m *NodeInfo) GetFreeMem() uint64 {
	if m != nil {
		return m.FreeMem
	}
	return 0
}

func (m *NodeInfo) GetTotalMem() uint64 {
	if m != nil {
		return m.TotalMem
	}
	return 0
}

func (m *NodeInfo) GetMemUsedPercent() float64 {
	if m != nil {
		return m.MemUsedPercent
	}
	return 0
}

func (m *NodeInfo) GetPathTotal() uint64 {
	if m != nil {
		return m.PathTotal
	}
	return 0
}

func (m *NodeInfo) GetPathFree() uint64 {
	if m != nil {
		return m.PathFree
	}
	return 0
}

func (m *NodeInfo) GetPathUsedPercent() float64 {
	if m != nil {
		return m.PathUsedPercent
	}
	return 0
}

func (m *NodeInfo) GetDiskIOs() []*DiskIO {
	if m != nil {
		return m.DiskIOs
	}
	return nil
}

func (m *NodeInfo) GetNetIOs() []*NetIO {
	if m != nil {
		return m.NetIOs
	}
	return nil
}

type DiskIO struct {
	ReadCount      uint64 `protobuf:"varint,1,opt,name=ReadCount" json:"ReadCount,omitempty"`
	WriteCount     uint64 `protobuf:"varint,2,opt,name=WriteCount" json:"WriteCount,omitempty"`
	ReadBytes      uint64 `protobuf:"varint,3,opt,name=ReadBytes" json:"ReadBytes,omitempty"`
	WriteBytes     uint64 `protobuf:"varint,4,opt,name=WriteBytes" json:"WriteBytes,omitempty"`
	IopsInProgress uint64 `protobuf:"varint,5,opt,name=IopsInProgress" json:"IopsInProgress,omitempty"`
	IoTime         uint64 `protobuf:"varint,6,opt,name=IoTime" json:"IoTime,omitempty"`
	WeightedIO     uint64 `protobuf:"varint,7,opt,name=WeightedIO" json:"WeightedIO,omitempty"`
	Name           string `protobuf:"bytes,8,opt,name=Name" json:"Name,omitempty"`
}

func (m *DiskIO) Reset()                    { *m = DiskIO{} }
func (m *DiskIO) String() string            { return proto.CompactTextString(m) }
func (*DiskIO) ProtoMessage()               {}
func (*DiskIO) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DiskIO) GetReadCount() uint64 {
	if m != nil {
		return m.ReadCount
	}
	return 0
}

func (m *DiskIO) GetWriteCount() uint64 {
	if m != nil {
		return m.WriteCount
	}
	return 0
}

func (m *DiskIO) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *DiskIO) GetWriteBytes() uint64 {
	if m != nil {
		return m.WriteBytes
	}
	return 0
}

func (m *DiskIO) GetIopsInProgress() uint64 {
	if m != nil {
		return m.IopsInProgress
	}
	return 0
}

func (m *DiskIO) GetIoTime() uint64 {
	if m != nil {
		return m.IoTime
	}
	return 0
}

func (m *DiskIO) GetWeightedIO() uint64 {
	if m != nil {
		return m.WeightedIO
	}
	return 0
}

func (m *DiskIO) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type NetIO struct {
	BytesSent   uint64 `protobuf:"varint,1,opt,name=BytesSent" json:"BytesSent,omitempty"`
	BytesRecv   uint64 `protobuf:"varint,2,opt,name=BytesRecv" json:"BytesRecv,omitempty"`
	PacketsSent uint64 `protobuf:"varint,3,opt,name=PacketsSent" json:"PacketsSent,omitempty"`
	PacketsRecv uint64 `protobuf:"varint,4,opt,name=PacketsRecv" json:"PacketsRecv,omitempty"`
	Errin       uint64 `protobuf:"varint,5,opt,name=Errin" json:"Errin,omitempty"`
	Errout      uint64 `protobuf:"varint,6,opt,name=Errout" json:"Errout,omitempty"`
	Dropin      uint64 `protobuf:"varint,7,opt,name=Dropin" json:"Dropin,omitempty"`
	Dropout     uint64 `protobuf:"varint,8,opt,name=Dropout" json:"Dropout,omitempty"`
	Name        string `protobuf:"bytes,9,opt,name=Name" json:"Name,omitempty"`
}

func (m *NetIO) Reset()                    { *m = NetIO{} }
func (m *NetIO) String() string            { return proto.CompactTextString(m) }
func (*NetIO) ProtoMessage()               {}
func (*NetIO) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *NetIO) GetBytesSent() uint64 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *NetIO) GetBytesRecv() uint64 {
	if m != nil {
		return m.BytesRecv
	}
	return 0
}

func (m *NetIO) GetPacketsSent() uint64 {
	if m != nil {
		return m.PacketsSent
	}
	return 0
}

func (m *NetIO) GetPacketsRecv() uint64 {
	if m != nil {
		return m.PacketsRecv
	}
	return 0
}

func (m *NetIO) GetErrin() uint64 {
	if m != nil {
		return m.Errin
	}
	return 0
}

func (m *NetIO) GetErrout() uint64 {
	if m != nil {
		return m.Errout
	}
	return 0
}

func (m *NetIO) GetDropin() uint64 {
	if m != nil {
		return m.Dropin
	}
	return 0
}

func (m *NetIO) GetDropout() uint64 {
	if m != nil {
		return m.Dropout
	}
	return 0
}

func (m *NetIO) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*WriteChunkReq)(nil), "dp.WriteChunkReq")
	proto.RegisterType((*WriteChunkAck)(nil), "dp.WriteChunkAck")
	proto.RegisterType((*Block)(nil), "dp.Block")
	proto.RegisterType((*CreateBlockGroupStreamReq)(nil), "dp.CreateBlockGroupStreamReq")
	proto.RegisterType((*CreateBlockGroupStreamAck)(nil), "dp.CreateBlockGroupStreamAck")
	proto.RegisterType((*StreamWriteReq)(nil), "dp.StreamWriteReq")
	proto.RegisterType((*StreamWriteAck)(nil), "dp.StreamWriteAck")
	proto.RegisterType((*StreamReadChunkReq)(nil), "dp.StreamReadChunkReq")
	proto.RegisterType((*StreamReadChunkAck)(nil), "dp.StreamReadChunkAck")
	proto.RegisterType((*DeleteChunkReq)(nil), "dp.DeleteChunkReq")
	proto.RegisterType((*DeleteChunkAck)(nil), "dp.DeleteChunkAck")
	proto.RegisterType((*DataNodeHealthCheckReq)(nil), "dp.DataNodeHealthCheckReq")
	proto.RegisterType((*DataNodeHealthCheckAck)(nil), "dp.DataNodeHealthCheckAck")
	proto.RegisterType((*RecvMigrateReq)(nil), "dp.RecvMigrateReq")
	proto.RegisterType((*RecvMigrateAck)(nil), "dp.RecvMigrateAck")
	proto.RegisterType((*FInfo)(nil), "dp.FInfo")
	proto.RegisterType((*SendAck)(nil), "dp.SendAck")
	proto.RegisterType((*NodeMonitorReq)(nil), "dp.NodeMonitorReq")
	proto.RegisterType((*NodeMonitorAck)(nil), "dp.NodeMonitorAck")
	proto.RegisterType((*NodeInfo)(nil), "dp.NodeInfo")
	proto.RegisterType((*DiskIO)(nil), "dp.DiskIO")
	proto.RegisterType((*NetIO)(nil), "dp.NetIO")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DataNode service

type DataNodeClient interface {
	WriteChunk(ctx context.Context, in *WriteChunkReq, opts ...grpc.CallOption) (*WriteChunkAck, error)
	StreamReadChunk(ctx context.Context, in *StreamReadChunkReq, opts ...grpc.CallOption) (DataNode_StreamReadChunkClient, error)
	DeleteChunk(ctx context.Context, in *DeleteChunkReq, opts ...grpc.CallOption) (*DeleteChunkAck, error)
	DataNodeHealthCheck(ctx context.Context, in *DataNodeHealthCheckReq, opts ...grpc.CallOption) (*DataNodeHealthCheckAck, error)
	RecvMigrateMsg(ctx context.Context, in *RecvMigrateReq, opts ...grpc.CallOption) (*RecvMigrateAck, error)
	SendMigrateData(ctx context.Context, opts ...grpc.CallOption) (DataNode_SendMigrateDataClient, error)
	C2MRepl(ctx context.Context, opts ...grpc.CallOption) (DataNode_C2MReplClient, error)
	M2SRepl(ctx context.Context, opts ...grpc.CallOption) (DataNode_M2SReplClient, error)
	S2BRepl(ctx context.Context, opts ...grpc.CallOption) (DataNode_S2BReplClient, error)
	NodeMonitor(ctx context.Context, in *NodeMonitorReq, opts ...grpc.CallOption) (*NodeMonitorAck, error)
}

type dataNodeClient struct {
	cc *grpc.ClientConn
}

func NewDataNodeClient(cc *grpc.ClientConn) DataNodeClient {
	return &dataNodeClient{cc}
}

func (c *dataNodeClient) WriteChunk(ctx context.Context, in *WriteChunkReq, opts ...grpc.CallOption) (*WriteChunkAck, error) {
	out := new(WriteChunkAck)
	err := grpc.Invoke(ctx, "/dp.DataNode/WriteChunk", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) StreamReadChunk(ctx context.Context, in *StreamReadChunkReq, opts ...grpc.CallOption) (DataNode_StreamReadChunkClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataNode_serviceDesc.Streams[0], c.cc, "/dp.DataNode/StreamReadChunk", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNodeStreamReadChunkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataNode_StreamReadChunkClient interface {
	Recv() (*StreamReadChunkAck, error)
	grpc.ClientStream
}

type dataNodeStreamReadChunkClient struct {
	grpc.ClientStream
}

func (x *dataNodeStreamReadChunkClient) Recv() (*StreamReadChunkAck, error) {
	m := new(StreamReadChunkAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNodeClient) DeleteChunk(ctx context.Context, in *DeleteChunkReq, opts ...grpc.CallOption) (*DeleteChunkAck, error) {
	out := new(DeleteChunkAck)
	err := grpc.Invoke(ctx, "/dp.DataNode/DeleteChunk", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) DataNodeHealthCheck(ctx context.Context, in *DataNodeHealthCheckReq, opts ...grpc.CallOption) (*DataNodeHealthCheckAck, error) {
	out := new(DataNodeHealthCheckAck)
	err := grpc.Invoke(ctx, "/dp.DataNode/DataNodeHealthCheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) RecvMigrateMsg(ctx context.Context, in *RecvMigrateReq, opts ...grpc.CallOption) (*RecvMigrateAck, error) {
	out := new(RecvMigrateAck)
	err := grpc.Invoke(ctx, "/dp.DataNode/RecvMigrateMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) SendMigrateData(ctx context.Context, opts ...grpc.CallOption) (DataNode_SendMigrateDataClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataNode_serviceDesc.Streams[1], c.cc, "/dp.DataNode/SendMigrateData", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNodeSendMigrateDataClient{stream}
	return x, nil
}

type DataNode_SendMigrateDataClient interface {
	Send(*FInfo) error
	CloseAndRecv() (*SendAck, error)
	grpc.ClientStream
}

type dataNodeSendMigrateDataClient struct {
	grpc.ClientStream
}

func (x *dataNodeSendMigrateDataClient) Send(m *FInfo) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataNodeSendMigrateDataClient) CloseAndRecv() (*SendAck, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SendAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNodeClient) C2MRepl(ctx context.Context, opts ...grpc.CallOption) (DataNode_C2MReplClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataNode_serviceDesc.Streams[2], c.cc, "/dp.DataNode/C2MRepl", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNodeC2MReplClient{stream}
	return x, nil
}

type DataNode_C2MReplClient interface {
	Send(*StreamWriteReq) error
	Recv() (*StreamWriteAck, error)
	grpc.ClientStream
}

type dataNodeC2MReplClient struct {
	grpc.ClientStream
}

func (x *dataNodeC2MReplClient) Send(m *StreamWriteReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataNodeC2MReplClient) Recv() (*StreamWriteAck, error) {
	m := new(StreamWriteAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNodeClient) M2SRepl(ctx context.Context, opts ...grpc.CallOption) (DataNode_M2SReplClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataNode_serviceDesc.Streams[3], c.cc, "/dp.DataNode/M2SRepl", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNodeM2SReplClient{stream}
	return x, nil
}

type DataNode_M2SReplClient interface {
	Send(*StreamWriteReq) error
	Recv() (*StreamWriteAck, error)
	grpc.ClientStream
}

type dataNodeM2SReplClient struct {
	grpc.ClientStream
}

func (x *dataNodeM2SReplClient) Send(m *StreamWriteReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataNodeM2SReplClient) Recv() (*StreamWriteAck, error) {
	m := new(StreamWriteAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNodeClient) S2BRepl(ctx context.Context, opts ...grpc.CallOption) (DataNode_S2BReplClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataNode_serviceDesc.Streams[4], c.cc, "/dp.DataNode/S2BRepl", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNodeS2BReplClient{stream}
	return x, nil
}

type DataNode_S2BReplClient interface {
	Send(*StreamWriteReq) error
	Recv() (*StreamWriteAck, error)
	grpc.ClientStream
}

type dataNodeS2BReplClient struct {
	grpc.ClientStream
}

func (x *dataNodeS2BReplClient) Send(m *StreamWriteReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataNodeS2BReplClient) Recv() (*StreamWriteAck, error) {
	m := new(StreamWriteAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNodeClient) NodeMonitor(ctx context.Context, in *NodeMonitorReq, opts ...grpc.CallOption) (*NodeMonitorAck, error) {
	out := new(NodeMonitorAck)
	err := grpc.Invoke(ctx, "/dp.DataNode/NodeMonitor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DataNode service

type DataNodeServer interface {
	WriteChunk(context.Context, *WriteChunkReq) (*WriteChunkAck, error)
	StreamReadChunk(*StreamReadChunkReq, DataNode_StreamReadChunkServer) error
	DeleteChunk(context.Context, *DeleteChunkReq) (*DeleteChunkAck, error)
	DataNodeHealthCheck(context.Context, *DataNodeHealthCheckReq) (*DataNodeHealthCheckAck, error)
	RecvMigrateMsg(context.Context, *RecvMigrateReq) (*RecvMigrateAck, error)
	SendMigrateData(DataNode_SendMigrateDataServer) error
	C2MRepl(DataNode_C2MReplServer) error
	M2SRepl(DataNode_M2SReplServer) error
	S2BRepl(DataNode_S2BReplServer) error
	NodeMonitor(context.Context, *NodeMonitorReq) (*NodeMonitorAck, error)
}

func RegisterDataNodeServer(s *grpc.Server, srv DataNodeServer) {
	s.RegisterService(&_DataNode_serviceDesc, srv)
}

func _DataNode_WriteChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteChunkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).WriteChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dp.DataNode/WriteChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).WriteChunk(ctx, req.(*WriteChunkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_StreamReadChunk_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamReadChunkReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataNodeServer).StreamReadChunk(m, &dataNodeStreamReadChunkServer{stream})
}

type DataNode_StreamReadChunkServer interface {
	Send(*StreamReadChunkAck) error
	grpc.ServerStream
}

type dataNodeStreamReadChunkServer struct {
	grpc.ServerStream
}

func (x *dataNodeStreamReadChunkServer) Send(m *StreamReadChunkAck) error {
	return x.ServerStream.SendMsg(m)
}

func _DataNode_DeleteChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChunkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).DeleteChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dp.DataNode/DeleteChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).DeleteChunk(ctx, req.(*DeleteChunkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_DataNodeHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataNodeHealthCheckReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).DataNodeHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dp.DataNode/DataNodeHealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).DataNodeHealthCheck(ctx, req.(*DataNodeHealthCheckReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_RecvMigrateMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecvMigrateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).RecvMigrateMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dp.DataNode/RecvMigrateMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).RecvMigrateMsg(ctx, req.(*RecvMigrateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_SendMigrateData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataNodeServer).SendMigrateData(&dataNodeSendMigrateDataServer{stream})
}

type DataNode_SendMigrateDataServer interface {
	SendAndClose(*SendAck) error
	Recv() (*FInfo, error)
	grpc.ServerStream
}

type dataNodeSendMigrateDataServer struct {
	grpc.ServerStream
}

func (x *dataNodeSendMigrateDataServer) SendAndClose(m *SendAck) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataNodeSendMigrateDataServer) Recv() (*FInfo, error) {
	m := new(FInfo)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataNode_C2MRepl_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataNodeServer).C2MRepl(&dataNodeC2MReplServer{stream})
}

type DataNode_C2MReplServer interface {
	Send(*StreamWriteAck) error
	Recv() (*StreamWriteReq, error)
	grpc.ServerStream
}

type dataNodeC2MReplServer struct {
	grpc.ServerStream
}

func (x *dataNodeC2MReplServer) Send(m *StreamWriteAck) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataNodeC2MReplServer) Recv() (*StreamWriteReq, error) {
	m := new(StreamWriteReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataNode_M2SRepl_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataNodeServer).M2SRepl(&dataNodeM2SReplServer{stream})
}

type DataNode_M2SReplServer interface {
	Send(*StreamWriteAck) error
	Recv() (*StreamWriteReq, error)
	grpc.ServerStream
}

type dataNodeM2SReplServer struct {
	grpc.ServerStream
}

func (x *dataNodeM2SReplServer) Send(m *StreamWriteAck) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataNodeM2SReplServer) Recv() (*StreamWriteReq, error) {
	m := new(StreamWriteReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataNode_S2BRepl_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataNodeServer).S2BRepl(&dataNodeS2BReplServer{stream})
}

type DataNode_S2BReplServer interface {
	Send(*StreamWriteAck) error
	Recv() (*StreamWriteReq, error)
	grpc.ServerStream
}

type dataNodeS2BReplServer struct {
	grpc.ServerStream
}

func (x *dataNodeS2BReplServer) Send(m *StreamWriteAck) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataNodeS2BReplServer) Recv() (*StreamWriteReq, error) {
	m := new(StreamWriteReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataNode_NodeMonitor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMonitorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).NodeMonitor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dp.DataNode/NodeMonitor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).NodeMonitor(ctx, req.(*NodeMonitorReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataNode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dp.DataNode",
	HandlerType: (*DataNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WriteChunk",
			Handler:    _DataNode_WriteChunk_Handler,
		},
		{
			MethodName: "DeleteChunk",
			Handler:    _DataNode_DeleteChunk_Handler,
		},
		{
			MethodName: "DataNodeHealthCheck",
			Handler:    _DataNode_DataNodeHealthCheck_Handler,
		},
		{
			MethodName: "RecvMigrateMsg",
			Handler:    _DataNode_RecvMigrateMsg_Handler,
		},
		{
			MethodName: "NodeMonitor",
			Handler:    _DataNode_NodeMonitor_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamReadChunk",
			Handler:       _DataNode_StreamReadChunk_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SendMigrateData",
			Handler:       _DataNode_SendMigrateData_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "C2MRepl",
			Handler:       _DataNode_C2MRepl_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "M2SRepl",
			Handler:       _DataNode_M2SRepl_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "S2BRepl",
			Handler:       _DataNode_S2BRepl_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "datanode.proto",
}

func init() { proto.RegisterFile("datanode.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1106 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xee, 0xda, 0xbb, 0xfe, 0x39, 0x4e, 0x9d, 0x32, 0x54, 0x91, 0x31, 0x08, 0xc2, 0x0a, 0x55,
	0xbe, 0x69, 0x84, 0x0c, 0x08, 0x09, 0x89, 0x8b, 0x3a, 0x4e, 0xa8, 0xa5, 0x38, 0x89, 0xc6, 0x2d,
	0x5c, 0x71, 0xb1, 0xb5, 0xc7, 0xb1, 0x65, 0x7b, 0x67, 0x99, 0x9d, 0xad, 0x54, 0xc4, 0x93, 0x70,
	0xc7, 0x2b, 0xf0, 0x1a, 0xbc, 0x04, 0x8f, 0x81, 0xc4, 0x0d, 0x3a, 0x67, 0x66, 0x7f, 0xed, 0x50,
	0xa9, 0xbd, 0xdb, 0xef, 0x3b, 0x73, 0xfe, 0xcf, 0x9c, 0xb1, 0xa1, 0xbb, 0x08, 0x74, 0x10, 0xca,
	0x85, 0x38, 0x8b, 0x94, 0xd4, 0x92, 0xd5, 0x16, 0x91, 0xff, 0x06, 0x1e, 0xfe, 0xa4, 0xd6, 0x5a,
	0x9c, 0xaf, 0x92, 0x70, 0xc3, 0xc5, 0x2f, 0xac, 0x07, 0x4d, 0xfa, 0x9e, 0x8c, 0x7b, 0xce, 0xa9,
	0x33, 0x70, 0x79, 0x0a, 0x51, 0x32, 0xda, 0xca, 0x39, 0x4a, 0x6a, 0x46, 0x62, 0x21, 0x4a, 0xc6,
	0x81, 0x0e, 0x5e, 0x25, 0xcb, 0x5e, 0xfd, 0xd4, 0x19, 0x1c, 0xf1, 0x14, 0xb2, 0x3e, 0xb4, 0xce,
	0xe5, 0x6e, 0xb7, 0xd6, 0x93, 0x71, 0xcf, 0x25, 0xa5, 0x0c, 0xfb, 0xdf, 0x17, 0x5d, 0x3f, 0x9b,
	0x6f, 0xd8, 0x23, 0xa8, 0x73, 0xa1, 0xc9, 0xad, 0xc7, 0xf1, 0xb3, 0xa4, 0x5e, 0xab, 0xa8, 0x7f,
	0x03, 0x1e, 0xf9, 0x67, 0x0c, 0xdc, 0x95, 0x8c, 0x8d, 0x5e, 0x9b, 0xd3, 0xf7, 0xfd, 0xb1, 0xfa,
	0x3f, 0xc3, 0x47, 0xe7, 0x4a, 0x04, 0x5a, 0x10, 0xf1, 0x83, 0x92, 0x49, 0x34, 0xd3, 0x4a, 0x04,
	0x3b, 0x4c, 0xfe, 0x13, 0x68, 0xcf, 0xb6, 0xc1, 0x6b, 0xf1, 0x3c, 0xb7, 0x97, 0x13, 0xcc, 0x87,
	0xa3, 0x5c, 0x29, 0xb3, 0x5c, 0xe2, 0xfc, 0xa7, 0xf7, 0x99, 0xb7, 0x09, 0xaa, 0x3c, 0x41, 0x25,
	0xb4, 0xff, 0x47, 0x0d, 0xba, 0x46, 0x4e, 0xa5, 0x78, 0x6b, 0x03, 0xd2, 0x32, 0xd7, 0xca, 0x65,
	0xb6, 0x92, 0x2b, 0x11, 0x52, 0x03, 0x1e, 0xf2, 0x14, 0xfe, 0x5f, 0x03, 0xd8, 0xe7, 0xd0, 0x98,
	0x06, 0xb1, 0x16, 0xaa, 0xe7, 0x9d, 0x3a, 0x83, 0xce, 0xb0, 0x7d, 0xb6, 0x88, 0xce, 0x28, 0x6e,
	0x6e, 0x05, 0xec, 0x33, 0xf0, 0x28, 0xff, 0x5e, 0xa3, 0x7a, 0xc2, 0xf0, 0x68, 0x63, 0x14, 0xcc,
	0x37, 0x49, 0xd4, 0x6b, 0xee, 0xd9, 0x30, 0x82, 0xbd, 0xb2, 0xb5, 0xf6, 0xcb, 0x86, 0x61, 0x9a,
	0x32, 0x4c, 0xc6, 0xbd, 0xb6, 0x09, 0x33, 0xc5, 0xfe, 0x9f, 0x4e, 0xa9, 0x46, 0x87, 0x27, 0xa5,
	0x50, 0xb5, 0x5a, 0xb9, 0x6a, 0xc5, 0x0a, 0xd4, 0x2b, 0x15, 0x28, 0xd4, 0xcd, 0x2d, 0xd7, 0xad,
	0x1a, 0xb4, 0xf7, 0x96, 0xa0, 0x1b, 0x95, 0xa0, 0x7f, 0x03, 0x96, 0x8e, 0x55, 0xb0, 0x78, 0xaf,
	0xcb, 0x75, 0x02, 0x8d, 0x9b, 0xe5, 0x32, 0x16, 0x9a, 0xa2, 0xaf, 0x73, 0x8b, 0xd0, 0x3b, 0xda,
	0x8e, 0xd7, 0xbf, 0x0a, 0x0a, 0xbe, 0xce, 0x33, 0xec, 0x9f, 0xed, 0x79, 0xc7, 0xaa, 0x15, 0xe6,
	0xc7, 0x29, 0xcd, 0x8f, 0x3f, 0x86, 0xee, 0x58, 0x6c, 0xc5, 0xfb, 0xad, 0x01, 0xdf, 0x2f, 0x59,
	0x39, 0xd8, 0x27, 0xbf, 0x07, 0x27, 0xe8, 0xf4, 0x5a, 0x2e, 0xc4, 0x73, 0x11, 0x6c, 0xf5, 0xea,
	0x7c, 0x25, 0xe6, 0xe8, 0xd1, 0xff, 0xf1, 0xa0, 0xe4, 0x70, 0xb7, 0x19, 0xb8, 0x2f, 0x63, 0xb1,
	0xa0, 0x00, 0x3c, 0x4e, 0xdf, 0x58, 0xa7, 0x99, 0x0e, 0x74, 0x12, 0x53, 0x9d, 0x3c, 0x6e, 0x91,
	0xff, 0xbb, 0x03, 0x5d, 0x2e, 0xe6, 0xaf, 0xa7, 0xeb, 0x3b, 0x15, 0x98, 0x2b, 0x86, 0x8d, 0x53,
	0xf3, 0xd1, 0x36, 0xcf, 0x2e, 0xc3, 0x56, 0x36, 0x95, 0x49, 0xa8, 0xc9, 0x7c, 0x9b, 0x67, 0x18,
	0x65, 0xe3, 0x58, 0x1b, 0x3d, 0x3b, 0x4a, 0x29, 0xa6, 0xe2, 0xc6, 0x9a, 0x16, 0x87, 0x4b, 0x6a,
	0x29, 0xb4, 0x5a, 0xc6, 0x62, 0xc3, 0x58, 0x4c, 0x31, 0x96, 0xac, 0x10, 0xdb, 0xe1, 0x92, 0x49,
	0xf0, 0x2e, 0x27, 0xe1, 0x52, 0x96, 0xdc, 0x3b, 0x15, 0xf7, 0x45, 0x27, 0xb5, 0xb2, 0x13, 0xf6,
	0x18, 0xbc, 0xcb, 0xeb, 0x60, 0x27, 0x28, 0xe6, 0x36, 0x37, 0x20, 0x9d, 0x86, 0x51, 0xb2, 0xa4,
	0x80, 0xed, 0x34, 0x8c, 0x92, 0xa5, 0xff, 0x31, 0x34, 0x67, 0x22, 0x5c, 0x1c, 0x8e, 0xe6, 0x11,
	0x74, 0xb1, 0x45, 0x53, 0x19, 0xae, 0xb5, 0x54, 0xd8, 0xb8, 0xab, 0x12, 0x73, 0xb8, 0x61, 0x03,
	0x68, 0xe1, 0x19, 0x4c, 0x83, 0xc2, 0xeb, 0x0c, 0x8f, 0x70, 0x51, 0xa4, 0x1c, 0xcf, 0xa4, 0xfe,
	0x5f, 0xb5, 0xfc, 0x28, 0xdd, 0xdd, 0x28, 0x79, 0x19, 0x07, 0x77, 0x82, 0xac, 0x39, 0x3c, 0xc3,
	0x34, 0xa1, 0x51, 0x72, 0x25, 0x03, 0x33, 0x06, 0x0e, 0x4f, 0x21, 0x4a, 0x2e, 0x95, 0x10, 0x53,
	0xb1, 0xb3, 0x5d, 0x4a, 0x21, 0xda, 0x7b, 0x21, 0x75, 0xb0, 0x45, 0x91, 0xdd, 0x86, 0x29, 0x66,
	0x4f, 0xa0, 0x3b, 0x15, 0x3b, 0x1c, 0xa5, 0x5b, 0xa1, 0xe6, 0x22, 0xd4, 0x74, 0xe7, 0x1d, 0x5e,
	0x61, 0xf1, 0x8d, 0xb8, 0x0d, 0xf4, 0x8a, 0xf4, 0xec, 0xb5, 0xcf, 0x09, 0xf4, 0x80, 0x00, 0x1d,
	0xd2, 0x46, 0x74, 0x79, 0x86, 0xd9, 0x00, 0x8e, 0xf1, 0xbb, 0xe8, 0xa2, 0x45, 0x2e, 0xaa, 0x34,
	0xfb, 0x02, 0x9a, 0xe3, 0x75, 0xbc, 0x99, 0xdc, 0xc4, 0xbd, 0xf6, 0x69, 0x7d, 0xd0, 0x19, 0x02,
	0x56, 0xcb, 0x50, 0x3c, 0x15, 0xe1, 0xee, 0xbd, 0x16, 0x1a, 0x0f, 0x01, 0x1d, 0xa2, 0xdd, 0x4b,
	0x0c, 0xb7, 0x02, 0xff, 0x1f, 0x07, 0x1a, 0xe6, 0x38, 0xc6, 0x4d, 0xdb, 0x80, 0x46, 0xc4, 0x8c,
	0x4f, 0x4e, 0xb0, 0x4f, 0x01, 0xcc, 0x63, 0x9c, 0x4d, 0x90, 0xcb, 0x0b, 0x4c, 0xaa, 0x3d, 0x7a,
	0xa3, 0x45, 0x6c, 0xab, 0x9a, 0x13, 0x99, 0xb6, 0x11, 0xbb, 0x05, 0x6d, 0x23, 0x7f, 0x02, 0xdd,
	0x89, 0x8c, 0xe2, 0x49, 0x78, 0xab, 0xe4, 0x9d, 0x12, 0x71, 0x6c, 0xf7, 0x69, 0x85, 0xc5, 0x3b,
	0x3c, 0x91, 0x2f, 0xd6, 0x3b, 0x61, 0x0b, 0x6b, 0x11, 0xd9, 0x17, 0xeb, 0xbb, 0x95, 0x16, 0x8b,
	0xc9, 0x8d, 0xad, 0x6b, 0x81, 0xc1, 0x7d, 0x40, 0x03, 0xde, 0x32, 0x3f, 0x01, 0xf0, 0xdb, 0xff,
	0xd7, 0x01, 0x8f, 0xaa, 0x80, 0xb1, 0x53, 0x18, 0x33, 0x91, 0x67, 0x9e, 0x11, 0x99, 0x14, 0xef,
	0xa1, 0x4d, 0x3c, 0x27, 0xd8, 0x29, 0x74, 0x6e, 0x83, 0xf9, 0x46, 0x68, 0xa3, 0x6d, 0x32, 0x2f,
	0x52, 0x85, 0x13, 0x64, 0xc1, 0x2d, 0x9d, 0x20, 0x1b, 0x8f, 0xc1, 0xbb, 0x50, 0x6a, 0x1d, 0xda,
	0xa4, 0x0d, 0xc0, 0x5c, 0x2f, 0x94, 0x92, 0x89, 0x4e, 0x73, 0x35, 0x08, 0xf9, 0xb1, 0x92, 0xd1,
	0x3a, 0xb4, 0x79, 0x5a, 0x44, 0xf7, 0x55, 0xc9, 0x08, 0x15, 0xcc, 0x0b, 0x9a, 0xc2, 0x2c, 0xfb,
	0x76, 0x9e, 0xfd, 0xf0, 0x6f, 0x17, 0x5a, 0xe9, 0x3a, 0x65, 0x5f, 0xa7, 0xcd, 0xc5, 0xbd, 0xcc,
	0x3e, 0xc0, 0x31, 0x29, 0xfd, 0xe8, 0xeb, 0x57, 0xa8, 0x67, 0xf3, 0x8d, 0xff, 0x80, 0x5d, 0xc0,
	0x71, 0xe5, 0x11, 0x61, 0x27, 0x78, 0x6e, 0xff, 0x5d, 0xeb, 0x1f, 0xe2, 0xc9, 0xc8, 0x97, 0x0e,
	0xfb, 0x16, 0x3a, 0x85, 0x57, 0x81, 0x31, 0x9a, 0xe4, 0xd2, 0x63, 0xd3, 0xaf, 0x72, 0xc6, 0xff,
	0x0d, 0x7c, 0x78, 0xe0, 0x41, 0x60, 0x7d, 0x3a, 0x7c, 0xf0, 0x0d, 0xe9, 0xdf, 0x27, 0x33, 0x06,
	0xbf, 0x2b, 0x2d, 0xdb, 0x69, 0x7c, 0x67, 0x82, 0x29, 0x3f, 0x0e, 0xfd, 0x2a, 0x67, 0x74, 0x9f,
	0xc2, 0x31, 0xee, 0x44, 0xcb, 0xa1, 0x0b, 0x46, 0xd7, 0x8d, 0x36, 0x73, 0xbf, 0x43, 0xf9, 0x9b,
	0x9d, 0xe9, 0x3f, 0x18, 0x60, 0xd2, 0xcd, 0xf3, 0xe1, 0x94, 0x8b, 0x68, 0x6b, 0x7c, 0x94, 0x7f,
	0xe3, 0xf5, 0xab, 0x9c, 0x55, 0xa3, 0x6a, 0x35, 0xa7, 0xc3, 0xd9, 0xbb, 0x29, 0xce, 0x86, 0xa3,
	0x77, 0x52, 0xec, 0x14, 0xd6, 0xb7, 0x51, 0x2e, 0x6f, 0xf8, 0x7e, 0x95, 0x23, 0xe5, 0x57, 0x0d,
	0xfa, 0x17, 0xf1, 0xd5, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xcf, 0x7a, 0xbe, 0xb4, 0x57, 0x0c,
	0x00, 0x00,
}
